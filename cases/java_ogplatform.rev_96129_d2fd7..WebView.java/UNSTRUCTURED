/**
 * Copyright (C) 2009 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.web.server;

<<<<<<< MINE
import java.util.HashMap;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

import javax.time.Instant;

import org.apache.commons.lang.ObjectUtils;
import org.cometd.Client;
import org.cometd.Message;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.opengamma.OpenGammaRuntimeException;
=======
import com.opengamma.DataNotFoundException;
>>>>>>> YOURS
import com.opengamma.engine.ComputationTargetSpecification;
import com.opengamma.engine.view.ViewComputationResultModel;
import com.opengamma.engine.view.ViewDeltaResultModel;
import com.opengamma.engine.view.client.ViewClient;
import com.opengamma.engine.view.compilation.CompiledViewDefinition;
import com.opengamma.engine.view.execution.ViewExecutionOptions;
import com.opengamma.engine.view.listener.AbstractViewResultListener;
import com.opengamma.id.UniqueId;
import com.opengamma.livedata.UserPrincipal;
import com.opengamma.util.tuple.Pair;
import com.opengamma.web.server.conversion.ConversionMode;
import com.opengamma.web.server.conversion.ResultConverterCache;
import com.opengamma.web.server.push.AnalyticsListener;
import com.opengamma.web.server.push.Viewport;
import com.opengamma.web.server.push.ViewportDefinition;
import org.apache.commons.lang.ObjectUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * TODO CONCURRENCY - I've scrapped all the locking, needs to be reviewed and replaced
 * TODO return new viewport instance rather than implementing it?
 */
public class WebView implements Viewport {

  private static final Logger s_logger = LoggerFactory.getLogger(WebView.class);
<<<<<<< MINE
  
  private static final String STARTED_DISPLAY_NAME = "Live";
  private static final String PAUSED_DISPLAY_NAME = "Paused";
  
  private final Client _local;
  private final Client _remote;
  private final ViewClient _client;
  private final UniqueId _baseViewDefinitionId;
  private final String _aggregatorName;
  private final UniqueId _viewDefinitionId;
  private final ViewExecutionOptions _executionOptions;
  private final ExecutorService _executorService;
=======

  private final ViewClient _viewClient;
  private final String _viewDefinitionName;
>>>>>>> YOURS
  private final ResultConverterCache _resultConverterCache;
  private final Map<String,Object> _latestResults = new HashMap<String, Object>();
  private final Object _lock = new Object();

  private RequirementBasedWebViewGrid _portfolioGrid;
  private RequirementBasedWebViewGrid _primitivesGrid;

  // TODO get the state from the grids
  private final AtomicInteger _activeDepGraphCount = new AtomicInteger();
  private ViewportDefinition _viewportDefinition;
  private AnalyticsListener _listener;
  private Map<String,Object> _gridStructures;
  private boolean _initialized = false;
  private boolean _sendAnalyticsUpdates = false;

<<<<<<< MINE
  public WebView(final Client local, final Client remote, final ViewClient client, final UniqueId baseViewDefinitionId,
      final String aggregatorName, final UniqueId viewDefinitionId, final ViewExecutionOptions executionOptions,
      final UserPrincipal user, final ExecutorService executorService, final ResultConverterCache resultConverterCache) {
    ArgumentChecker.notNull(executionOptions, "executionOptions");
    _local = local;
    _remote = remote;
    _client = client;
    _baseViewDefinitionId = baseViewDefinitionId;
    _aggregatorName = aggregatorName;
    _viewDefinitionId = viewDefinitionId;
    _executionOptions = executionOptions;
    _executorService = executorService;
=======
  public WebView(ViewClient viewClient,
                 String viewDefinitionName,
                 ResultConverterCache resultConverterCache,
                 ViewportDefinition viewportDefinition,
                 AnalyticsListener listener) {
    _viewClient = viewClient;
    _viewDefinitionName = viewDefinitionName;
>>>>>>> YOURS
    _resultConverterCache = resultConverterCache;
    _viewportDefinition = viewportDefinition;
    _listener = listener;
    _viewClient.setResultListener(new AbstractViewResultListener() {
      
      @Override
      public UserPrincipal getUser() {
        // Authentication needed
        return UserPrincipal.getLocalUser();
      }
      
      @Override
      public void viewDefinitionCompiled(CompiledViewDefinition compiledViewDefinition, boolean hasMarketDataPermissions) {     
        s_logger.info("View definition compiled: {}", compiledViewDefinition.getViewDefinition().getName());
        initGrids(compiledViewDefinition);
      }
      
      @Override
      public void cycleCompleted(ViewComputationResultModel fullResult, ViewDeltaResultModel deltaResult) {
<<<<<<< MINE
        s_logger.info("New result arrived for view '{}'", getViewDefinitionId());
        _updateLock.lock();
        try {
          if (_awaitingNextUpdate) {
            _awaitingNextUpdate = false;
            sendImmediateUpdate();
          }
        } finally {
          _updateLock.unlock();
        }
=======
        s_logger.info("New result arrived for view '{}'", getViewDefinitionName());
        updateResults();
>>>>>>> YOURS
      }

    });
<<<<<<< MINE
    
    client.attachToViewProcess(viewDefinitionId, executionOptions);
=======
    _viewClient.attachToViewProcess(viewDefinitionName, viewportDefinition.getExecutionOptions());
>>>>>>> YOURS
  }

  // TODO make sure an update event is published when the view defs compile?
  private void initGrids(CompiledViewDefinition compiledViewDefinition) {
    synchronized (_lock) {
      WebViewPortfolioGrid portfolioGrid = new WebViewPortfolioGrid(_viewClient, compiledViewDefinition, _resultConverterCache);

      _gridStructures = new HashMap<String, Object>();

      if (portfolioGrid.getGridStructure().isEmpty()) {
        _portfolioGrid = null;
      } else {
        _portfolioGrid = portfolioGrid;
        _gridStructures.put("portfolio", _portfolioGrid.getInitialJsonGridStructure());
        _gridStructures.put("portfolio", _portfolioGrid.getInitialJsonGridStructure());
      }

      RequirementBasedWebViewGrid primitivesGrid = new WebViewPrimitivesGrid(_viewClient, compiledViewDefinition, _resultConverterCache);
      if (primitivesGrid.getGridStructure().isEmpty()) {
        _primitivesGrid = null;
      } else {
        _primitivesGrid = primitivesGrid;
        _gridStructures.put("primitives", _primitivesGrid.getInitialJsonGridStructure());
      }
      _initialized = true;
      _listener.gridStructureChanged();
      configureGridViewports();
    }
  }

  /* package */ void pause() {
    synchronized (_lock) {
      _viewClient.pause();
    }
  }

  /* package */ void resume() {
    synchronized (_lock) {
      _viewClient.resume();
    }
  }

  /* package */ void shutdown() {
    // Removes all listeners
    synchronized (_lock) {
      _viewClient.shutdown();
    }
  }
  
<<<<<<< MINE
  public UniqueId getBaseViewDefinitionId() {
    return _baseViewDefinitionId;
  }
  
  public String getAggregatorName() {
    return _aggregatorName;
  }
  
  public UniqueId getViewDefinitionId() {
    return _viewDefinitionId;
  }
  
  public ViewExecutionOptions getExecutionOptions() {
    return _executionOptions;
  }
  
  public boolean matches(UniqueId baseViewDefinitionId, String aggregatorName, ViewExecutionOptions executionOptions) {
    return getBaseViewDefinitionId().equals(baseViewDefinitionId)
        && ObjectUtils.equals(getAggregatorName(), aggregatorName) && ObjectUtils.equals(getExecutionOptions(), executionOptions);
  }
  
  public WebViewGrid getGridByName(String name) {
    return _gridsByName.get(name);
  }
  
  @SuppressWarnings("unchecked")
  public void triggerUpdate(Message message) {
    Map<String, Object> dataMap = (Map<String, Object>) message.getData();
    boolean immediateResponse = (Boolean) dataMap.get("immediateResponse");
    
    if (getPortfolioGrid() != null) {
      Map<String, Object> portfolioViewport = (Map<String, Object>) dataMap.get("portfolioViewport");
      getPortfolioGrid().setViewport(processViewportData(portfolioViewport));
=======
  public String getViewDefinitionName() {
    synchronized (_lock) {
      return _viewDefinitionName;
>>>>>>> YOURS
    }
  }

  /* package */ boolean matches(String viewDefinitionName, ViewExecutionOptions executionOptions) {
    synchronized (_lock) {
      return _viewDefinitionName.equals(viewDefinitionName) &&
          ObjectUtils.equals(_viewportDefinition.getExecutionOptions(), executionOptions);
    }
  }

  private WebViewGrid getGridByName(String name) {
    if (_primitivesGrid != null) {
      if (_primitivesGrid.getName().equals(name)) {
        return _primitivesGrid;
      }
      WebViewGrid depGraphGrid = _primitivesGrid.getDepGraphGrid(name);
      if (depGraphGrid != null) {
        return depGraphGrid;
      }
    }
    if (_portfolioGrid != null) {
      if (_portfolioGrid.getName().equals(name)) {
        return _portfolioGrid;
      } else {
        return _portfolioGrid.getDepGraphGrid(name);
      }
    }
    return null;
  }

  /**
   *
   */
  /* package */ Viewport configureViewport(ViewportDefinition viewportDefinition,
                                           AnalyticsListener listener,
                                           String viewportKey) {
    synchronized (_lock) {
      _viewportDefinition = viewportDefinition;
      _listener = listener;
      configureGridViewports();
      return this;
    }
  }

  private void configureGridViewports() {
    if (!_initialized) {
      return;
    }
    _portfolioGrid.setViewport(_viewportDefinition.getPortfolioRows());
    _portfolioGrid.updateDepGraphCells(_viewportDefinition.getPortfolioDependencyGraphCells());
    _primitivesGrid.setViewport(_viewportDefinition.getPrimitiveRows());
    _primitivesGrid.updateDepGraphCells(_viewportDefinition.getPrimitiveDependencyGraphCells());
    // TODO _client.setViewCycleAccessSupported()?
    updateResults();
  }

  private void updateResults() {
    synchronized (_lock) {
      if (!_viewClient.isResultAvailable()) {
        return;
      }
      ViewComputationResultModel resultModel = _viewClient.getLatestResult();
      long resultTimestamp = resultModel.getCalculationTime().toEpochMillisLong();
      HashMap<Integer, Map<String, Object>> portfolioResult = new HashMap<Integer, Map<String, Object>>();
      HashMap<Integer, Map<String, Object>> primitiveResult = new HashMap<Integer, Map<String, Object>>();

      for (ComputationTargetSpecification target : resultModel.getAllTargets()) {
        switch (target.getType()) {
          case PRIMITIVE:
            if (_primitivesGrid != null) {
              Map<String, Object> targetResult = _primitivesGrid.getTargetResult(target, resultModel.getTargetResult(target), resultTimestamp);
              if (targetResult != null) {
                Integer rowId = (Integer) targetResult.get("rowId");
                primitiveResult.put(rowId, targetResult);
              }
            }
            break;
          case PORTFOLIO_NODE:
          case POSITION:
            if (_portfolioGrid != null) {
              Map<String, Object> targetResult = _portfolioGrid.getTargetResult(target, resultModel.getTargetResult(target), resultTimestamp);
              if (targetResult != null) {
                Integer rowId = (Integer) targetResult.get("rowId");
                portfolioResult.put(rowId, targetResult);
              }
            }
        }
      }
      _latestResults.clear();
      _latestResults.put("portfolio", portfolioResult);
      _latestResults.put("primitive", primitiveResult);
      if (_sendAnalyticsUpdates) {
        _sendAnalyticsUpdates = false;
        _listener.dataChanged();
      }
    }
  }

<<<<<<< MINE
  private void runUpdateThread() {
    getExecutorService().submit(new Runnable() {
      @Override
      public void run() {
        do {
          ViewComputationResultModel update = getViewClient().getLatestResult();
          
          getRemote().startBatch();
          
          long valuationTimeMillis = update.getValuationTime().toEpochMillisLong();
          long calculationDurationMillis = update.getCalculationDuration().toMillisLong();
          
          sendStartMessage(valuationTimeMillis, calculationDurationMillis);
          try {
            processResult(update);
          } catch (Exception e) {
            s_logger.error("Error processing result from view cycle " + update.getViewCycleId(), e);
          }
          sendEndMessage();
          
          getRemote().endBatch();
        } while (continueUpdateThread());
      }
    });
  }
  
  private boolean continueUpdateThread() {
    _updateLock.lock();
    try {
      if (_continueUpdateThread) {
        _continueUpdateThread = false;
        return true;
      } else {
        _updateThreadRunning = false;
        return false;
      }
    } finally {
      _updateLock.unlock();
    }
  }
  
  private void processResult(ViewComputationResultModel resultModel) {
    long resultTimestamp = resultModel.getCalculationTime().toEpochMillisLong();
    
    if (getPrimitivesGrid() != null) {
      for (ComputationTargetSpecification target : getPrimitivesGrid().getGridStructure().getTargets().keySet()) {
        getPrimitivesGrid().processTargetResult(target, resultModel.getTargetResult(target), resultTimestamp);
      }
    }
    
    if (getPortfolioGrid() != null) {
      for (ComputationTargetSpecification target : getPortfolioGrid().getGridStructure().getTargets().keySet()) {
        getPortfolioGrid().processTargetResult(target, resultModel.getTargetResult(target), resultTimestamp);
      }
      getPortfolioGrid().processDepGraphs(resultTimestamp);
    }
  }
  
  /**
   * Tells the remote client that updates are starting.
   */
  private void sendStartMessage(long valuationTimeEpochMillis, long calculationDurationMillis) {
    Map<String, Object> startMessage = new HashMap<String, Object>();
    startMessage.put("valuationTime", valuationTimeEpochMillis);
    startMessage.put("calculationDuration", calculationDurationMillis);
    getRemote().deliver(getLocal(), "/updates/control/start", startMessage, null);
  }

  /**
   * Tells the remote client that updates have finished.
   */
  private void sendEndMessage() {
    getRemote().deliver(getLocal(), "/updates/control/end", new HashMap<String, Object>(), null);
  }
  
  private void sendViewStatus(boolean isRunning, String status) {
    Map<String, Object> output = new HashMap<String, Object>();
    output.put("isRunning", isRunning);
    output.put("status", status);
    getRemote().deliver(getLocal(), "/status", output, null);
  }
  
  //-------------------------------------------------------------------------
  
  public Map<String, Object> getInitialJsonGridStructures() {
    Map<String, Object> gridStructures = new HashMap<String, Object>();
    if (getPrimitivesGrid() != null) {
      gridStructures.put("primitives", getPrimitivesGrid().getInitialJsonGridStructure());
    }
    if (getPortfolioGrid() != null) {
      gridStructures.put("portfolio", getPortfolioGrid().getInitialJsonGridStructure());
    }
    return gridStructures;
  }
  
  public void setIncludeDepGraph(String parentGridName, WebGridCell cell, boolean includeDepGraph) {
    if (!getPortfolioGrid().getName().equals(parentGridName)) {
      throw new OpenGammaRuntimeException("Invalid or unknown grid for dependency graph viewing: " + parentGridName);
    }
    
=======
  // TODO this logic need to go in configureViewport
  private void setIncludeDepGraph(WebGridCell cell, boolean includeDepGraph) {
    // TODO this is ugly, the dep graph count belongs in the portfolio grid
>>>>>>> YOURS
    if (includeDepGraph) {
      if (_activeDepGraphCount.getAndIncrement() == 0) {
        _viewClient.setViewCycleAccessSupported(true);
      }
    } else {
      if (_activeDepGraphCount.decrementAndGet() == 0) {
        _viewClient.setViewCycleAccessSupported(false);
      }
    }
    /*WebViewGrid grid = _portfolioGrid.setIncludeDepGraph(cell, includeDepGraph);
    if (grid != null) {
      if (includeDepGraph) {
        _gridsByName.put(grid.getName(), grid);
      } else {
        _gridsByName.remove(grid.getName());
      }
    }*/
  }

  // TODO refactor this?
  // TODO CONCURRENCY
  public Pair<Instant, String> getGridContentsAsCsv(String gridName) {
    WebViewGrid grid = getGridByName(gridName);
    if (grid == null) {
      throw new DataNotFoundException("Unknown grid '" + gridName + "'");
    }
    ViewComputationResultModel latestResult = _viewClient.getLatestResult();
    if (latestResult == null) {
      return null;
    }
    String csv = grid.dumpContentsToCsv(latestResult);
    return Pair.of(latestResult.getValuationTime(), csv);
  }

  @Override
  public Map<String, Object> getGridStructure() {
    synchronized (_lock) {
      return _gridStructures;
    }
  }

  @Override
  public Map<String, Object> getLatestResults() {
    synchronized (_lock) {
      _sendAnalyticsUpdates = true;
      return _latestResults;
    }
  }

  @Override
  public void setRunning(boolean run) {
    throw new UnsupportedOperationException("setRunning not implemented");
  }

  @Override
  public void setConversionMode(ConversionMode mode) {
    throw new UnsupportedOperationException("setConversionMode not implemented");
  }
}