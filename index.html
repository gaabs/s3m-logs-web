<!doctype html>
<html lang="en" dir="ltr">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" type="text/css" href="dist/diff2html.css">

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
  <style media="screen">
    table,
    th,
    td {
      /* border: 1px solid grey;
      padding: 8px; */
    }

    .row>div {
      border: 1px solid grey;
    }
  </style>
  <title></title>
</head>

<body>
  <div class="container-fluid">

    <h1>S3M Renaming Analysis</h1>
    <table class="table">
      <tr>
        <td>
          <details>
            <summary>Case X - cassandra/rev_0f1fb_8b0e1/ColumnIndex.java</summary>
            <ul>
              <li>Construtor do Builder</li>
              <ul>
                <li>Left alterou assinatura, corpo, e adicionou 1 overload</li>
                <li>Right alterou corpo</li>
                <li>Unstructured acusou conflito nos argumentos e no overload</li>
                <li>Safe deu match com vazio, e manteve duas outras versões do método</li>
                <li>MM e KB mantiveram três versões</li>
              </ul>
            </ul>
            <table class="table table-bordered">
              <tr>
                <td>
                  <details>
                    <summary>Base</summary>
                    <pre class="prettyprint"><code>
                      /*
                       * Licensed to the Apache Software Foundation (ASF) under one
                       * or more contributor license agreements.  See the NOTICE file
                       * distributed with this work for additional information
                       * regarding copyright ownership.  The ASF licenses this file
                       * to you under the Apache License, Version 2.0 (the
                       * "License"); you may not use this file except in compliance
                       * with the License.  You may obtain a copy of the License at
                       *
                       *     http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */
                      package org.apache.cassandra.db;

                      import java.io.DataOutput;
                      import java.io.IOException;
                      import java.nio.ByteBuffer;
                      import java.util.*;

                      import org.apache.cassandra.config.DatabaseDescriptor;
                      import org.apache.cassandra.io.sstable.IndexHelper;
                      import org.apache.cassandra.utils.AlwaysPresentFilter;
                      import org.apache.cassandra.utils.IFilter;
                      import org.apache.cassandra.utils.FilterFactory;

                      public class ColumnIndex
                      {
                          public final List<IndexHelper.IndexInfo> columnsIndex;
                          public final IFilter bloomFilter;

                          private static final ColumnIndex EMPTY = new ColumnIndex(Collections.<IndexHelper.IndexInfo>emptyList(), new AlwaysPresentFilter());

                          private ColumnIndex(int estimatedColumnCount)
                          {
                              this(new ArrayList<IndexHelper.IndexInfo>(), FilterFactory.getFilter(estimatedColumnCount, 4, false));
                          }

                          private ColumnIndex(List<IndexHelper.IndexInfo> columnsIndex, IFilter bloomFilter)
                          {
                              this.columnsIndex = columnsIndex;
                              this.bloomFilter = bloomFilter;
                          }

                          /**
                           * Help to create an index for a column family based on size of columns,
                           * and write said columns to disk.
                           */
                          public static class Builder
                          {
                              private final ColumnIndex result;
                              private final long indexOffset;
                              private long startPosition = -1;
                              private long endPosition = 0;
                              private long blockSize;
                              private OnDiskAtom firstColumn;
                              private OnDiskAtom lastColumn;
                              private OnDiskAtom lastBlockClosing;
                              private final DataOutput output;
                              private final RangeTombstone.Tracker tombstoneTracker;
                              private final OnDiskAtom.Serializer atomSerializer;
                              private int atomCount;

                              public Builder(ColumnFamily cf,
                                             ByteBuffer key,
                                             int estimatedColumnCount,
                                             DataOutput output)
                              {
                                  this.indexOffset = rowHeaderSize(key, cf.deletionInfo());
                                  this.result = new ColumnIndex(estimatedColumnCount);
                                  this.output = output;
                                  this.atomSerializer = cf.getOnDiskSerializer();
                                  this.tombstoneTracker = new RangeTombstone.Tracker(cf.getComparator());
                              }

                              /**
                               * Returns the number of bytes between the beginning of the row and the
                               * first serialized column.
                               */
                              private static long rowHeaderSize(ByteBuffer key, DeletionInfo delInfo)
                              {
                                  TypeSizes typeSizes = TypeSizes.NATIVE;
                                  // TODO fix constantSize when changing the nativeconststs.
                                  int keysize = key.remaining();
                                  return typeSizes.sizeof((short) keysize) + keysize          // Row key
                                       + typeSizes.sizeof(0L)                                 // Row data size
                                       + DeletionTime.serializer.serializedSize(delInfo.getTopLevelDeletion(), typeSizes)
                                       + typeSizes.sizeof(0);                                 // Column count
                              }

                              public RangeTombstone.Tracker tombstoneTracker()
                              {
                                  return tombstoneTracker;
                              }

                              public int writtenAtomCount()
                              {
                                  return atomCount + tombstoneTracker.writtenAtom();
                              }

                              /**
                               * Serializes the index into in-memory structure with all required components
                               * such as Bloom Filter, index block size, IndexInfo list
                               *
                               * @param cf Column family to create index for
                               *
                               * @return information about index - it's Bloom Filter, block size and IndexInfo list
                               */
                              public ColumnIndex build(ColumnFamily cf) throws IOException
                              {
                                  Iterator<RangeTombstone> rangeIter = cf.deletionInfo().rangeIterator();
                                  RangeTombstone tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  Comparator<ByteBuffer> comparator = cf.getComparator();

                                  for (IColumn c : cf)
                                  {
                                      while (tombstone != null && comparator.compare(c.name(), tombstone.min) >= 0)
                                      {
                                          add(tombstone);
                                          tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                      }
                                      add(c);
                                  }

                                  while (tombstone != null)
                                  {
                                      add(tombstone);
                                      tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  }
                                  return build();
                              }

                              public ColumnIndex build(Iterable<OnDiskAtom> columns) throws IOException
                              {
                                  for (OnDiskAtom c : columns)
                                      add(c);

                                  return build();
                              }

                              public void add(OnDiskAtom column) throws IOException
                              {
                                  atomCount++;

                                  if (column instanceof IColumn)
                                      result.bloomFilter.add(column.name());

                                  if (firstColumn == null)
                                  {
                                      firstColumn = column;
                                      startPosition = endPosition;
                                      // TODO: have that use the firstColumn as min + make sure we
                                      // optimize that on read
                                      endPosition += tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);
                                      blockSize = 0; // We don't count repeated tombstone marker in the block size, to avoid a situation
                                                     // where we wouldn't make any problem because a block is filled by said marker
                                  }

                                  long size = column.serializedSizeForSSTable();
                                  endPosition += size;
                                  blockSize += size;

                                  // if we hit the column index size that we have to index after, go ahead and index it.
                                  if (blockSize >= DatabaseDescriptor.getColumnIndexSize())
                                  {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), column.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                      firstColumn = null;
                                      lastBlockClosing = column;
                                  }

                                  if (output != null)
                                      atomSerializer.serializeForSSTable(column, output);

                                  // TODO: Should deal with removing unneeded tombstones
                                  tombstoneTracker.update(column);

                                  lastColumn = column;
                              }

                              public ColumnIndex build()
                              {
                                  // all columns were GC'd after all
                                  if (lastColumn == null)
                                      return ColumnIndex.EMPTY;

                                  // the last column may have fallen on an index boundary already.  if not, index it explicitly.
                                  if (result.columnsIndex.isEmpty() || lastBlockClosing != lastColumn)
                                  {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), lastColumn.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                  }

                                  // we should always have at least one computed index block, but we only write it out if there is more than that.
                                  assert result.columnsIndex.size() > 0;
                                  return result;
                              }
                          }
                      }

                    </code></pre>
                  </details>
                </td>
                <td>
                  <details>
                    <summary>Left</summary>
                    <pre class="prettyprint"><code>
                      /*
                       * Licensed to the Apache Software Foundation (ASF) under one
                       * or more contributor license agreements.  See the NOTICE file
                       * distributed with this work for additional information
                       * regarding copyright ownership.  The ASF licenses this file
                       * to you under the Apache License, Version 2.0 (the
                       * "License"); you may not use this file except in compliance
                       * with the License.  You may obtain a copy of the License at
                       *
                       *     http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */
                      package org.apache.cassandra.db;

                      import java.io.DataOutput;
                      import java.io.IOException;
                      import java.nio.ByteBuffer;
                      import java.util.*;

                      import org.apache.cassandra.config.DatabaseDescriptor;
                      import org.apache.cassandra.io.sstable.IndexHelper;
                      import org.apache.cassandra.utils.AlwaysPresentFilter;
                      import org.apache.cassandra.utils.IFilter;
                      import org.apache.cassandra.utils.FilterFactory;

                      public class ColumnIndex
                      {
                          public final List<IndexHelper.IndexInfo> columnsIndex;
                          public final IFilter bloomFilter;

                          private static final ColumnIndex EMPTY = new ColumnIndex(Collections.<IndexHelper.IndexInfo>emptyList(), new AlwaysPresentFilter());

                          private ColumnIndex(int estimatedColumnCount)
                          {
                              this(new ArrayList<IndexHelper.IndexInfo>(), FilterFactory.getFilter(estimatedColumnCount, 4, false));
                          }

                          private ColumnIndex(List<IndexHelper.IndexInfo> columnsIndex, IFilter bloomFilter)
                          {
                              this.columnsIndex = columnsIndex;
                              this.bloomFilter = bloomFilter;
                          }

                          /**
                           * Help to create an index for a column family based on size of columns,
                           * and write said columns to disk.
                           */
                          public static class Builder
                          {
                              private final ColumnIndex result;
                              private final long indexOffset;
                              private long startPosition = -1;
                              private long endPosition = 0;
                              private long blockSize;
                              private OnDiskAtom firstColumn;
                              private OnDiskAtom lastColumn;
                              private OnDiskAtom lastBlockClosing;
                              private final DataOutput output;
                              private final RangeTombstone.Tracker tombstoneTracker;
                              private final OnDiskAtom.Serializer atomSerializer;
                              private int atomCount;

                              public Builder(ColumnFamily cf,
                                             ByteBuffer key,
                                             int estimatedColumnCount,
                                             DataOutput output,
                                             boolean fromStream)
                              {
                                  this.indexOffset = rowHeaderSize(key, cf.deletionInfo());
                                  this.result = new ColumnIndex(estimatedColumnCount);
                                  this.output = output;
                                  this.atomSerializer = cf.getOnDiskSerializer();
                                  this.tombstoneTracker = fromStream ? null : new RangeTombstone.Tracker(cf.getComparator());
                              }

                              public Builder(ColumnFamily cf,
                                             ByteBuffer key,
                                             int estimatedColumnCount,
                                             DataOutput output)
                              {
                                  this(cf, key, estimatedColumnCount, output, false);
                              }

                              /**
                               * Returns the number of bytes between the beginning of the row and the
                               * first serialized column.
                               */
                              private static long rowHeaderSize(ByteBuffer key, DeletionInfo delInfo)
                              {
                                  TypeSizes typeSizes = TypeSizes.NATIVE;
                                  // TODO fix constantSize when changing the nativeconststs.
                                  int keysize = key.remaining();
                                  return typeSizes.sizeof((short) keysize) + keysize          // Row key
                                       + typeSizes.sizeof(0L)                                 // Row data size
                                       + DeletionTime.serializer.serializedSize(delInfo.getTopLevelDeletion(), typeSizes)
                                       + typeSizes.sizeof(0);                                 // Column count
                              }

                              public RangeTombstone.Tracker tombstoneTracker()
                              {
                                  return tombstoneTracker;
                              }

                              public int writtenAtomCount()
                              {
                                  return tombstoneTracker == null ? atomCount : atomCount + tombstoneTracker.writtenAtom();
                              }

                              /**
                               * Serializes the index into in-memory structure with all required components
                               * such as Bloom Filter, index block size, IndexInfo list
                               *
                               * @param cf Column family to create index for
                               *
                               * @return information about index - it's Bloom Filter, block size and IndexInfo list
                               */
                              public ColumnIndex build(ColumnFamily cf) throws IOException
                              {
                                  Iterator<RangeTombstone> rangeIter = cf.deletionInfo().rangeIterator();
                                  RangeTombstone tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  Comparator<ByteBuffer> comparator = cf.getComparator();

                                  for (IColumn c : cf)
                                  {
                                      while (tombstone != null && comparator.compare(c.name(), tombstone.min) >= 0)
                                      {
                                          add(tombstone);
                                          tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                      }
                                      add(c);
                                  }

                                  while (tombstone != null)
                                  {
                                      add(tombstone);
                                      tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  }
                                  return build();
                              }

                              public ColumnIndex build(Iterable<OnDiskAtom> columns) throws IOException
                              {
                                  for (OnDiskAtom c : columns)
                                      add(c);

                                  return build();
                              }

                              public void add(OnDiskAtom column) throws IOException
                              {
                                  atomCount++;

                                  if (column instanceof IColumn)
                                      result.bloomFilter.add(column.name());

                                  if (firstColumn == null)
                                  {
                                      firstColumn = column;
                                      startPosition = endPosition;
                                      // TODO: have that use the firstColumn as min + make sure we optimize that on read
                                      if (tombstoneTracker != null)
                                          endPosition += tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);
                                      blockSize = 0; // We don't count repeated tombstone marker in the block size, to avoid a situation
                                                     // where we wouldn't make any progress because a block is filled by said marker
                                  }

                                  long size = column.serializedSizeForSSTable();
                                  endPosition += size;
                                  blockSize += size;

                                  // if we hit the column index size that we have to index after, go ahead and index it.
                                  if (blockSize >= DatabaseDescriptor.getColumnIndexSize())
                                  {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), column.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                      firstColumn = null;
                                      lastBlockClosing = column;
                                  }

                                  if (output != null)
                                      atomSerializer.serializeForSSTable(column, output);

                                  // TODO: Should deal with removing unneeded tombstones
                                  if (tombstoneTracker != null)
                                      tombstoneTracker.update(column);

                                  lastColumn = column;
                              }

                              public ColumnIndex build()
                              {
                                  // all columns were GC'd after all
                                  if (lastColumn == null)
                                      return ColumnIndex.EMPTY;

                                  // the last column may have fallen on an index boundary already.  if not, index it explicitly.
                                  if (result.columnsIndex.isEmpty() || lastBlockClosing != lastColumn)
                                  {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), lastColumn.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                  }

                                  // we should always have at least one computed index block, but we only write it out if there is more than that.
                                  assert result.columnsIndex.size() > 0;
                                  return result;
                              }
                          }
                      }

    </code></pre>
                  </details>
                </td>
                <td>
                  <details>
                    <summary>Right</summary>
                    <pre class="prettyprint"><code>
                      /*
                       * Licensed to the Apache Software Foundation (ASF) under one
                       * or more contributor license agreements.  See the NOTICE file
                       * distributed with this work for additional information
                       * regarding copyright ownership.  The ASF licenses this file
                       * to you under the Apache License, Version 2.0 (the
                       * "License"); you may not use this file except in compliance
                       * with the License.  You may obtain a copy of the License at
                       *
                       *     http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */
                      package org.apache.cassandra.db;

                      import java.io.DataOutput;
                      import java.io.IOException;
                      import java.nio.ByteBuffer;
                      import java.util.*;

                      import org.apache.cassandra.config.DatabaseDescriptor;
                      import org.apache.cassandra.io.sstable.IndexHelper;

                      public class ColumnIndex
                      {
                          public final List<IndexHelper.IndexInfo> columnsIndex;

                          private static final ColumnIndex EMPTY = new ColumnIndex(Collections.<IndexHelper.IndexInfo>emptyList());

                          private ColumnIndex(List<IndexHelper.IndexInfo> columnsIndex)
                          {
                              this.columnsIndex = columnsIndex;
                          }

                          /**
                           * Help to create an index for a column family based on size of columns,
                           * and write said columns to disk.
                           */
                          public static class Builder
                          {
                              private static final OnDiskAtom.Serializer atomSerializer = Column.onDiskSerializer();

                              private final ColumnIndex result;
                              private final long indexOffset;
                              private long startPosition = -1;
                              private long endPosition = 0;
                              private long blockSize;
                              private OnDiskAtom firstColumn;
                              private OnDiskAtom lastColumn;
                              private OnDiskAtom lastBlockClosing;
                              private final DataOutput output;
                              private final RangeTombstone.Tracker tombstoneTracker;
                              private int atomCount;

                              public Builder(ColumnFamily cf,
                                             ByteBuffer key,
                                             DataOutput output)
                              {
                                  this.indexOffset = rowHeaderSize(key, cf.deletionInfo());
                                  this.result = new ColumnIndex(new ArrayList<IndexHelper.IndexInfo>());
                                  this.output = output;
                                  this.tombstoneTracker = new RangeTombstone.Tracker(cf.getComparator());
                              }

                              /**
                               * Returns the number of bytes between the beginning of the row and the
                               * first serialized column.
                               */
                              private static long rowHeaderSize(ByteBuffer key, DeletionInfo delInfo)
                              {
                                  TypeSizes typeSizes = TypeSizes.NATIVE;
                                  // TODO fix constantSize when changing the nativeconststs.
                                  int keysize = key.remaining();
                                  return typeSizes.sizeof((short) keysize) + keysize          // Row key
                                       + typeSizes.sizeof(0L)                                 // Row data size
                                       + DeletionTime.serializer.serializedSize(delInfo.getTopLevelDeletion(), typeSizes)
                                       + typeSizes.sizeof(0);                                 // Column count
                              }

                              public RangeTombstone.Tracker tombstoneTracker()
                              {
                                  return tombstoneTracker;
                              }

                              public int writtenAtomCount()
                              {
                                  return atomCount + tombstoneTracker.writtenAtom();
                              }

                              /**
                               * Serializes the index into in-memory structure with all required components
                               * such as Bloom Filter, index block size, IndexInfo list
                               *
                               * @param cf Column family to create index for
                               *
                               * @return information about index - it's Bloom Filter, block size and IndexInfo list
                               */
                              public ColumnIndex build(ColumnFamily cf) throws IOException
                              {
                                  Iterator<RangeTombstone> rangeIter = cf.deletionInfo().rangeIterator();
                                  RangeTombstone tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  Comparator<ByteBuffer> comparator = cf.getComparator();

                                  for (Column c : cf)
                                  {
                                      while (tombstone != null && comparator.compare(c.name(), tombstone.min) >= 0)
                                      {
                                          add(tombstone);
                                          tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                      }
                                      add(c);
                                  }

                                  while (tombstone != null)
                                  {
                                      add(tombstone);
                                      tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  }
                                  return build();
                              }

                              public ColumnIndex build(Iterable<OnDiskAtom> columns) throws IOException
                              {
                                  for (OnDiskAtom c : columns)
                                      add(c);

                                  return build();
                              }

                              public void add(OnDiskAtom column) throws IOException
                              {
                                  atomCount++;

                                  if (firstColumn == null)
                                  {
                                      firstColumn = column;
                                      startPosition = endPosition;
                                      // TODO: have that use the firstColumn as min + make sure we
                                      // optimize that on read
                                      endPosition += tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);
                                      blockSize = 0; // We don't count repeated tombstone marker in the block size, to avoid a situation
                                                     // where we wouldn't make any problem because a block is filled by said marker
                                  }

                                  long size = column.serializedSizeForSSTable();
                                  endPosition += size;
                                  blockSize += size;

                                  // if we hit the column index size that we have to index after, go ahead and index it.
                                  if (blockSize >= DatabaseDescriptor.getColumnIndexSize())
                                  {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), column.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                      firstColumn = null;
                                      lastBlockClosing = column;
                                  }

                                  if (output != null)
                                      atomSerializer.serializeForSSTable(column, output);

                                  // TODO: Should deal with removing unneeded tombstones
                                  tombstoneTracker.update(column);

                                  lastColumn = column;
                              }

                              public ColumnIndex build()
                              {
                                  // all columns were GC'd after all
                                  if (lastColumn == null)
                                      return ColumnIndex.EMPTY;

                                  // the last column may have fallen on an index boundary already.  if not, index it explicitly.
                                  if (result.columnsIndex.isEmpty() || lastBlockClosing != lastColumn)
                                  {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), lastColumn.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                  }

                                  // we should always have at least one computed index block, but we only write it out if there is more than that.
                                  assert result.columnsIndex.size() > 0;
                                  return result;
                              }
                          }
                      }

                    </code></pre>
                  </details>
                </td>
                <td>
                  <details>
                    <summary>MergeMethods</summary>
                    <pre class="prettyprint"><code>
                      /*
                       * Licensed to the Apache Software Foundation (ASF) under one
                       * or more contributor license agreements.  See the NOTICE file
                       * distributed with this work for additional information
                       * regarding copyright ownership.  The ASF licenses this file
                       * to you under the Apache License, Version 2.0 (the
                       * "License"); you may not use this file except in compliance
                       * with the License.  You may obtain a copy of the License at
                       *
                       *     http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */
                      package org.apache.cassandra.db;

                      import java.io.DataOutput;
                      import java.io.IOException;
                      import java.nio.ByteBuffer;
                      import java.util.*;
                      import org.apache.cassandra.config.DatabaseDescriptor;
                      import org.apache.cassandra.io.sstable.IndexHelper;

                      public class ColumnIndex {

                          public final List<IndexHelper.IndexInfo> columnsIndex;

                          private static final ColumnIndex EMPTY = new ColumnIndex(Collections.<IndexHelper.IndexInfo>emptyList());

                          private ColumnIndex(List<IndexHelper.IndexInfo> columnsIndex) {
                              this.columnsIndex = columnsIndex;
                          }

                          /**
                           * Help to create an index for a column family based on size of columns,
                           * and write said columns to disk.
                           */
                          public static class Builder {

                              private static final OnDiskAtom.Serializer atomSerializer = Column.onDiskSerializer();

                              private final ColumnIndex result;

                              private final long indexOffset;

                              private long startPosition = -1;

                              private long endPosition = 0;

                              private long blockSize;

                              private OnDiskAtom firstColumn;

                              private OnDiskAtom lastColumn;

                              private OnDiskAtom lastBlockClosing;

                              private final DataOutput output;

                              private final RangeTombstone.Tracker tombstoneTracker;

                              private int atomCount;

                              public Builder(ColumnFamily cf, ByteBuffer key, int estimatedColumnCount, DataOutput output, boolean fromStream) {
                                  this.indexOffset = rowHeaderSize(key, cf.deletionInfo());
                                  this.result = new ColumnIndex(estimatedColumnCount);
                                  this.output = output;
                                  this.atomSerializer = cf.getOnDiskSerializer();
                                  this.tombstoneTracker = fromStream ? null : new RangeTombstone.Tracker(cf.getComparator());
                              }

                              public Builder(ColumnFamily cf, ByteBuffer key, int estimatedColumnCount, DataOutput output) {
                                  this(cf, key, estimatedColumnCount, output, false);
                              }

                              public Builder(ColumnFamily cf, ByteBuffer key, DataOutput output) {
                                  this.indexOffset = rowHeaderSize(key, cf.deletionInfo());
                                  this.result = new ColumnIndex(new ArrayList<IndexHelper.IndexInfo>());
                                  this.output = output;
                                  this.tombstoneTracker = new RangeTombstone.Tracker(cf.getComparator());
                              }

                              /**
                               * Returns the number of bytes between the beginning of the row and the
                               * first serialized column.
                               */
                              private static long rowHeaderSize(ByteBuffer key, DeletionInfo delInfo) {
                                  TypeSizes typeSizes = TypeSizes.NATIVE;
                                  // TODO fix constantSize when changing the nativeconststs.
                                  int keysize = key.remaining();
                                  return // Row key
                                  typeSizes.sizeof((short) keysize) + keysize + // Row data size
                                  typeSizes.sizeof(0L) + DeletionTime.serializer.serializedSize(delInfo.getTopLevelDeletion(), typeSizes) + // Column count
                                  typeSizes.sizeof(0);
                              }

                              public RangeTombstone.Tracker tombstoneTracker() {
                                  return tombstoneTracker;
                              }

                              public int writtenAtomCount() {
                                  return tombstoneTracker == null ? atomCount : atomCount + tombstoneTracker.writtenAtom();
                              }

                              /**
                               * Serializes the index into in-memory structure with all required components
                               * such as Bloom Filter, index block size, IndexInfo list
                               *
                               * @param cf Column family to create index for
                               *
                               * @return information about index - it's Bloom Filter, block size and IndexInfo list
                               */
                              public ColumnIndex build(ColumnFamily cf) throws IOException {
                                  Iterator<RangeTombstone> rangeIter = cf.deletionInfo().rangeIterator();
                                  RangeTombstone tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  Comparator<ByteBuffer> comparator = cf.getComparator();
                                  for (Column c : cf) {
                                      while (tombstone != null && comparator.compare(c.name(), tombstone.min) >= 0) {
                                          add(tombstone);
                                          tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                      }
                                      add(c);
                                  }
                                  while (tombstone != null) {
                                      add(tombstone);
                                      tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  }
                                  return build();
                              }

                              public ColumnIndex build(Iterable<OnDiskAtom> columns) throws IOException {
                                  for (OnDiskAtom c : columns) add(c);
                                  return build();
                              }

                              public void add(OnDiskAtom column) throws IOException {
                                  atomCount++;
                                  if (firstColumn == null) {
                                      firstColumn = column;
                                      startPosition = endPosition;
                                      // TODO: have that use the firstColumn as min + make sure we optimize that on read
                                      if (tombstoneTracker != null)
                                          endPosition += tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);
                                      // We don't count repeated tombstone marker in the block size, to avoid a situation
                                      blockSize = 0;
                                  // where we wouldn't make any progress because a block is filled by said marker
                                  }
                                  long size = column.serializedSizeForSSTable();
                                  endPosition += size;
                                  blockSize += size;
                                  // if we hit the column index size that we have to index after, go ahead and index it.
                                  if (blockSize >= DatabaseDescriptor.getColumnIndexSize()) {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), column.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                      firstColumn = null;
                                      lastBlockClosing = column;
                                  }
                                  if (output != null)
                                      atomSerializer.serializeForSSTable(column, output);
                                  // TODO: Should deal with removing unneeded tombstones
                                  if (tombstoneTracker != null)
                                      tombstoneTracker.update(column);
                                  lastColumn = column;
                              }

                              public ColumnIndex build() {
                                  // all columns were GC'd after all
                                  if (lastColumn == null)
                                      return ColumnIndex.EMPTY;
                                  // the last column may have fallen on an index boundary already.  if not, index it explicitly.
                                  if (result.columnsIndex.isEmpty() || lastBlockClosing != lastColumn) {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), lastColumn.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                  }
                                  // we should always have at least one computed index block, but we only write it out if there is more than that.
                                  assert result.columnsIndex.size() > 0;
                                  return result;
                              }
                          }
                      }

                    </code></pre>
                  </details>
                </td>
                <td>
                  <details>
                    <summary>KeepBothMethods</summary>
                    <pre class="prettyprint"><code>
                      /*
                       * Licensed to the Apache Software Foundation (ASF) under one
                       * or more contributor license agreements.  See the NOTICE file
                       * distributed with this work for additional information
                       * regarding copyright ownership.  The ASF licenses this file
                       * to you under the Apache License, Version 2.0 (the
                       * "License"); you may not use this file except in compliance
                       * with the License.  You may obtain a copy of the License at
                       *
                       *     http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */
                      package org.apache.cassandra.db;

                      import java.io.DataOutput;
                      import java.io.IOException;
                      import java.nio.ByteBuffer;
                      import java.util.*;
                      import org.apache.cassandra.config.DatabaseDescriptor;
                      import org.apache.cassandra.io.sstable.IndexHelper;

                      public class ColumnIndex {

                          public final List<IndexHelper.IndexInfo> columnsIndex;

                          private static final ColumnIndex EMPTY = new ColumnIndex(Collections.<IndexHelper.IndexInfo>emptyList());

                          private ColumnIndex(List<IndexHelper.IndexInfo> columnsIndex) {
                              this.columnsIndex = columnsIndex;
                          }

                          /**
                           * Help to create an index for a column family based on size of columns,
                           * and write said columns to disk.
                           */
                          public static class Builder {

                              private static final OnDiskAtom.Serializer atomSerializer = Column.onDiskSerializer();

                              private final ColumnIndex result;

                              private final long indexOffset;

                              private long startPosition = -1;

                              private long endPosition = 0;

                              private long blockSize;

                              private OnDiskAtom firstColumn;

                              private OnDiskAtom lastColumn;

                              private OnDiskAtom lastBlockClosing;

                              private final DataOutput output;

                              private final RangeTombstone.Tracker tombstoneTracker;

                              private int atomCount;

                              public Builder(ColumnFamily cf, ByteBuffer key, int estimatedColumnCount, DataOutput output, boolean fromStream) {
                                  this.indexOffset = rowHeaderSize(key, cf.deletionInfo());
                                  this.result = new ColumnIndex(estimatedColumnCount);
                                  this.output = output;
                                  this.atomSerializer = cf.getOnDiskSerializer();
                                  this.tombstoneTracker = fromStream ? null : new RangeTombstone.Tracker(cf.getComparator());
                              }

                              public Builder(ColumnFamily cf, ByteBuffer key, int estimatedColumnCount, DataOutput output) {
                                  this(cf, key, estimatedColumnCount, output, false);
                              }

                              public Builder(ColumnFamily cf, ByteBuffer key, DataOutput output) {
                                  this.indexOffset = rowHeaderSize(key, cf.deletionInfo());
                                  this.result = new ColumnIndex(new ArrayList<IndexHelper.IndexInfo>());
                                  this.output = output;
                                  this.tombstoneTracker = new RangeTombstone.Tracker(cf.getComparator());
                              }

                              /**
                               * Returns the number of bytes between the beginning of the row and the
                               * first serialized column.
                               */
                              private static long rowHeaderSize(ByteBuffer key, DeletionInfo delInfo) {
                                  TypeSizes typeSizes = TypeSizes.NATIVE;
                                  // TODO fix constantSize when changing the nativeconststs.
                                  int keysize = key.remaining();
                                  return // Row key
                                  typeSizes.sizeof((short) keysize) + keysize + // Row data size
                                  typeSizes.sizeof(0L) + DeletionTime.serializer.serializedSize(delInfo.getTopLevelDeletion(), typeSizes) + // Column count
                                  typeSizes.sizeof(0);
                              }

                              public RangeTombstone.Tracker tombstoneTracker() {
                                  return tombstoneTracker;
                              }

                              public int writtenAtomCount() {
                                  return tombstoneTracker == null ? atomCount : atomCount + tombstoneTracker.writtenAtom();
                              }

                              /**
                               * Serializes the index into in-memory structure with all required components
                               * such as Bloom Filter, index block size, IndexInfo list
                               *
                               * @param cf Column family to create index for
                               *
                               * @return information about index - it's Bloom Filter, block size and IndexInfo list
                               */
                              public ColumnIndex build(ColumnFamily cf) throws IOException {
                                  Iterator<RangeTombstone> rangeIter = cf.deletionInfo().rangeIterator();
                                  RangeTombstone tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  Comparator<ByteBuffer> comparator = cf.getComparator();
                                  for (Column c : cf) {
                                      while (tombstone != null && comparator.compare(c.name(), tombstone.min) >= 0) {
                                          add(tombstone);
                                          tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                      }
                                      add(c);
                                  }
                                  while (tombstone != null) {
                                      add(tombstone);
                                      tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  }
                                  return build();
                              }

                              public ColumnIndex build(Iterable<OnDiskAtom> columns) throws IOException {
                                  for (OnDiskAtom c : columns) add(c);
                                  return build();
                              }

                              public void add(OnDiskAtom column) throws IOException {
                                  atomCount++;
                                  if (firstColumn == null) {
                                      firstColumn = column;
                                      startPosition = endPosition;
                                      // TODO: have that use the firstColumn as min + make sure we optimize that on read
                                      if (tombstoneTracker != null)
                                          endPosition += tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);
                                      // We don't count repeated tombstone marker in the block size, to avoid a situation
                                      blockSize = 0;
                                  // where we wouldn't make any progress because a block is filled by said marker
                                  }
                                  long size = column.serializedSizeForSSTable();
                                  endPosition += size;
                                  blockSize += size;
                                  // if we hit the column index size that we have to index after, go ahead and index it.
                                  if (blockSize >= DatabaseDescriptor.getColumnIndexSize()) {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), column.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                      firstColumn = null;
                                      lastBlockClosing = column;
                                  }
                                  if (output != null)
                                      atomSerializer.serializeForSSTable(column, output);
                                  // TODO: Should deal with removing unneeded tombstones
                                  if (tombstoneTracker != null)
                                      tombstoneTracker.update(column);
                                  lastColumn = column;
                              }

                              public ColumnIndex build() {
                                  // all columns were GC'd after all
                                  if (lastColumn == null)
                                      return ColumnIndex.EMPTY;
                                  // the last column may have fallen on an index boundary already.  if not, index it explicitly.
                                  if (result.columnsIndex.isEmpty() || lastBlockClosing != lastColumn) {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), lastColumn.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                  }
                                  // we should always have at least one computed index block, but we only write it out if there is more than that.
                                  assert result.columnsIndex.size() > 0;
                                  return result;
                              }
                          }
                      }

                    </code></pre>
                  </details>
                </td>
                <td>
                  <details>
                    <summary>Safe</summary>
                    <pre class="prettyprint"><code>
                      /*
                       * Licensed to the Apache Software Foundation (ASF) under one
                       * or more contributor license agreements.  See the NOTICE file
                       * distributed with this work for additional information
                       * regarding copyright ownership.  The ASF licenses this file
                       * to you under the Apache License, Version 2.0 (the
                       * "License"); you may not use this file except in compliance
                       * with the License.  You may obtain a copy of the License at
                       *
                       *     http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */
                      package org.apache.cassandra.db;

                      import java.io.DataOutput;
                      import java.io.IOException;
                      import java.nio.ByteBuffer;
                      import java.util.*;

                      import org.apache.cassandra.config.DatabaseDescriptor;
                      import org.apache.cassandra.io.sstable.IndexHelper;



                      public  class  ColumnIndex {

                          public final List<IndexHelper.IndexInfo> columnsIndex;




                          private static final ColumnIndex EMPTY = new ColumnIndex(Collections.<IndexHelper.IndexInfo>emptyList());








                          private ColumnIndex(List<IndexHelper.IndexInfo> columnsIndex)
                          {
                              this.columnsIndex = columnsIndex;
                          }


                          /**
                           * Help to create an index for a column family based on size of columns,
                           * and write said columns to disk.
                           */
                          public static  class  Builder {

                              private static final OnDiskAtom.Serializer atomSerializer = Column.onDiskSerializer();

                              private final ColumnIndex result;

                              private final long indexOffset;

                              private long startPosition = -1;

                              private long endPosition = 0;

                              private long blockSize;

                              private OnDiskAtom firstColumn;

                              private OnDiskAtom lastColumn;

                              private OnDiskAtom lastBlockClosing;

                              private final DataOutput output;

                              private final RangeTombstone.Tracker tombstoneTracker;

                              private int atomCount;


                              public Builder(ColumnFamily cf,
                                             ByteBuffer key,
                                             int estimatedColumnCount,
                                             DataOutput output,
                                             boolean fromStream)
                              {
                                  this.indexOffset = rowHeaderSize(key, cf.deletionInfo());
                                  this.result = new ColumnIndex(estimatedColumnCount);
                                  this.output = output;
                                  this.atomSerializer = cf.getOnDiskSerializer();
                                  this.tombstoneTracker = fromStream ? null : new RangeTombstone.Tracker(cf.getComparator());
                              }


                              <<<<<<< MINE

                      =======
                      public Builder(ColumnFamily cf,
                                             ByteBuffer key,
                                             int estimatedColumnCount,
                                             DataOutput output)
                              {
                                  this(cf, key, estimatedColumnCount, output, false);
                              }

                      >>>>>>> YOURS


                              public Builder(ColumnFamily cf,
                                             ByteBuffer key,
                                             DataOutput output)
                              {
                                  this.indexOffset = rowHeaderSize(key, cf.deletionInfo());
                                  this.result = new ColumnIndex(new ArrayList<IndexHelper.IndexInfo>());
                                  this.output = output;
                                  this.tombstoneTracker = new RangeTombstone.Tracker(cf.getComparator());
                              }


                              /**
                               * Returns the number of bytes between the beginning of the row and the
                               * first serialized column.
                               */
                              private static long rowHeaderSize(ByteBuffer key, DeletionInfo delInfo)
                              {
                                  TypeSizes typeSizes = TypeSizes.NATIVE;
                                  // TODO fix constantSize when changing the nativeconststs.
                                  int keysize = key.remaining();
                                  return typeSizes.sizeof((short) keysize) + keysize          // Row key
                                       + typeSizes.sizeof(0L)                                 // Row data size
                                       + DeletionTime.serializer.serializedSize(delInfo.getTopLevelDeletion(), typeSizes)
                                       + typeSizes.sizeof(0);                                 // Column count
                              }


                              public RangeTombstone.Tracker tombstoneTracker()
                              {
                                  return tombstoneTracker;
                              }


                              public int writtenAtomCount()
                              {
                                  return tombstoneTracker == null ? atomCount : atomCount + tombstoneTracker.writtenAtom();
                              }


                              /**
                               * Serializes the index into in-memory structure with all required components
                               * such as Bloom Filter, index block size, IndexInfo list
                               *
                               * @param cf Column family to create index for
                               *
                               * @return information about index - it's Bloom Filter, block size and IndexInfo list
                               */
                              public ColumnIndex build(ColumnFamily cf) throws IOException
                              {
                                  Iterator<RangeTombstone> rangeIter = cf.deletionInfo().rangeIterator();
                                  RangeTombstone tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  Comparator<ByteBuffer> comparator = cf.getComparator();

                                  for (Column c : cf)
                                  {
                                      while (tombstone != null && comparator.compare(c.name(), tombstone.min) >= 0)
                                      {
                                          add(tombstone);
                                          tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                      }
                                      add(c);
                                  }

                                  while (tombstone != null)
                                  {
                                      add(tombstone);
                                      tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  }
                                  return build();
                              }


                              public ColumnIndex build(Iterable<OnDiskAtom> columns) throws IOException
                              {
                                  for (OnDiskAtom c : columns)
                                      add(c);

                                  return build();
                              }


                              public void add(OnDiskAtom column) throws IOException
                              {
                                  atomCount++;

                                  if (firstColumn == null)
                                  {
                                      firstColumn = column;
                                      startPosition = endPosition;
                                      // TODO: have that use the firstColumn as min + make sure we optimize that on read
                                      if (tombstoneTracker != null)
                                      endPosition += tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);
                                      blockSize = 0; // We don't count repeated tombstone marker in the block size, to avoid a situation
                                                     // where we wouldn't make any progress because a block is filled by said marker
                                  }

                                  long size = column.serializedSizeForSSTable();
                                  endPosition += size;
                                  blockSize += size;

                                  // if we hit the column index size that we have to index after, go ahead and index it.
                                  if (blockSize >= DatabaseDescriptor.getColumnIndexSize())
                                  {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), column.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                      firstColumn = null;
                                      lastBlockClosing = column;
                                  }

                                  if (output != null)
                                      atomSerializer.serializeForSSTable(column, output);

                                  // TODO: Should deal with removing unneeded tombstones
                                  if (tombstoneTracker != null)
                                  tombstoneTracker.update(column);

                                  lastColumn = column;
                              }


                              public ColumnIndex build()
                              {
                                  // all columns were GC'd after all
                                  if (lastColumn == null)
                                      return ColumnIndex.EMPTY;

                                  // the last column may have fallen on an index boundary already.  if not, index it explicitly.
                                  if (result.columnsIndex.isEmpty() || lastBlockClosing != lastColumn)
                                  {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), lastColumn.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                  }

                                  // we should always have at least one computed index block, but we only write it out if there is more than that.
                                  assert result.columnsIndex.size() > 0;
                                  return result;
                              }

                      	}

                      }

                    </code></pre>
                  </details>
                </td>
                <td>
                  <details>
                    <summary>Unstructured</summary>
                    <pre class="prettyprint"><code>
                      /*
                       * Licensed to the Apache Software Foundation (ASF) under one
                       * or more contributor license agreements.  See the NOTICE file
                       * distributed with this work for additional information
                       * regarding copyright ownership.  The ASF licenses this file
                       * to you under the Apache License, Version 2.0 (the
                       * "License"); you may not use this file except in compliance
                       * with the License.  You may obtain a copy of the License at
                       *
                       *     http://www.apache.org/licenses/LICENSE-2.0
                       *
                       * Unless required by applicable law or agreed to in writing, software
                       * distributed under the License is distributed on an "AS IS" BASIS,
                       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                       * See the License for the specific language governing permissions and
                       * limitations under the License.
                       */
                      package org.apache.cassandra.db;

                      import java.io.DataOutput;
                      import java.io.IOException;
                      import java.nio.ByteBuffer;
                      import java.util.*;

                      import org.apache.cassandra.config.DatabaseDescriptor;
                      import org.apache.cassandra.io.sstable.IndexHelper;

                      public class ColumnIndex
                      {
                          public final List<IndexHelper.IndexInfo> columnsIndex;

                          private static final ColumnIndex EMPTY = new ColumnIndex(Collections.<IndexHelper.IndexInfo>emptyList());

                          private ColumnIndex(List<IndexHelper.IndexInfo> columnsIndex)
                          {
                              this.columnsIndex = columnsIndex;
                          }

                          /**
                           * Help to create an index for a column family based on size of columns,
                           * and write said columns to disk.
                           */
                          public static class Builder
                          {
                              private static final OnDiskAtom.Serializer atomSerializer = Column.onDiskSerializer();

                              private final ColumnIndex result;
                              private final long indexOffset;
                              private long startPosition = -1;
                              private long endPosition = 0;
                              private long blockSize;
                              private OnDiskAtom firstColumn;
                              private OnDiskAtom lastColumn;
                              private OnDiskAtom lastBlockClosing;
                              private final DataOutput output;
                              private final RangeTombstone.Tracker tombstoneTracker;
                              private int atomCount;

                              public Builder(ColumnFamily cf,
                                             ByteBuffer key,
                      <<<<<<< MINE
                                             int estimatedColumnCount,
                                             DataOutput output,
                                             boolean fromStream)
                      =======
                                             DataOutput output)
                      >>>>>>> YOURS
                              {
                                  this.indexOffset = rowHeaderSize(key, cf.deletionInfo());
                                  this.result = new ColumnIndex(new ArrayList<IndexHelper.IndexInfo>());
                                  this.output = output;
                      <<<<<<< MINE
                                  this.atomSerializer = cf.getOnDiskSerializer();
                                  this.tombstoneTracker = fromStream ? null : new RangeTombstone.Tracker(cf.getComparator());
                              }

                              public Builder(ColumnFamily cf,
                                             ByteBuffer key,
                                             int estimatedColumnCount,
                                             DataOutput output)
                              {
                                  this(cf, key, estimatedColumnCount, output, false);
                      =======
                                  this.tombstoneTracker = new RangeTombstone.Tracker(cf.getComparator());
                      >>>>>>> YOURS
                              }

                              /**
                               * Returns the number of bytes between the beginning of the row and the
                               * first serialized column.
                               */
                              private static long rowHeaderSize(ByteBuffer key, DeletionInfo delInfo)
                              {
                                  TypeSizes typeSizes = TypeSizes.NATIVE;
                                  // TODO fix constantSize when changing the nativeconststs.
                                  int keysize = key.remaining();
                                  return typeSizes.sizeof((short) keysize) + keysize          // Row key
                                       + typeSizes.sizeof(0L)                                 // Row data size
                                       + DeletionTime.serializer.serializedSize(delInfo.getTopLevelDeletion(), typeSizes)
                                       + typeSizes.sizeof(0);                                 // Column count
                              }

                              public RangeTombstone.Tracker tombstoneTracker()
                              {
                                  return tombstoneTracker;
                              }

                              public int writtenAtomCount()
                              {
                                  return tombstoneTracker == null ? atomCount : atomCount + tombstoneTracker.writtenAtom();
                              }

                              /**
                               * Serializes the index into in-memory structure with all required components
                               * such as Bloom Filter, index block size, IndexInfo list
                               *
                               * @param cf Column family to create index for
                               *
                               * @return information about index - it's Bloom Filter, block size and IndexInfo list
                               */
                              public ColumnIndex build(ColumnFamily cf) throws IOException
                              {
                                  Iterator<RangeTombstone> rangeIter = cf.deletionInfo().rangeIterator();
                                  RangeTombstone tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  Comparator<ByteBuffer> comparator = cf.getComparator();

                                  for (Column c : cf)
                                  {
                                      while (tombstone != null && comparator.compare(c.name(), tombstone.min) >= 0)
                                      {
                                          add(tombstone);
                                          tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                      }
                                      add(c);
                                  }

                                  while (tombstone != null)
                                  {
                                      add(tombstone);
                                      tombstone = rangeIter.hasNext() ? rangeIter.next() : null;
                                  }
                                  return build();
                              }

                              public ColumnIndex build(Iterable<OnDiskAtom> columns) throws IOException
                              {
                                  for (OnDiskAtom c : columns)
                                      add(c);

                                  return build();
                              }

                              public void add(OnDiskAtom column) throws IOException
                              {
                                  atomCount++;

                                  if (firstColumn == null)
                                  {
                                      firstColumn = column;
                                      startPosition = endPosition;
                                      // TODO: have that use the firstColumn as min + make sure we optimize that on read
                                      if (tombstoneTracker != null)
                                          endPosition += tombstoneTracker.writeOpenedMarker(firstColumn, output, atomSerializer);
                                      blockSize = 0; // We don't count repeated tombstone marker in the block size, to avoid a situation
                                                     // where we wouldn't make any progress because a block is filled by said marker
                                  }

                                  long size = column.serializedSizeForSSTable();
                                  endPosition += size;
                                  blockSize += size;

                                  // if we hit the column index size that we have to index after, go ahead and index it.
                                  if (blockSize >= DatabaseDescriptor.getColumnIndexSize())
                                  {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), column.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                      firstColumn = null;
                                      lastBlockClosing = column;
                                  }

                                  if (output != null)
                                      atomSerializer.serializeForSSTable(column, output);

                                  // TODO: Should deal with removing unneeded tombstones
                                  if (tombstoneTracker != null)
                                      tombstoneTracker.update(column);

                                  lastColumn = column;
                              }

                              public ColumnIndex build()
                              {
                                  // all columns were GC'd after all
                                  if (lastColumn == null)
                                      return ColumnIndex.EMPTY;

                                  // the last column may have fallen on an index boundary already.  if not, index it explicitly.
                                  if (result.columnsIndex.isEmpty() || lastBlockClosing != lastColumn)
                                  {
                                      IndexHelper.IndexInfo cIndexInfo = new IndexHelper.IndexInfo(firstColumn.name(), lastColumn.name(), indexOffset + startPosition, endPosition - startPosition);
                                      result.columnsIndex.add(cIndexInfo);
                                  }

                                  // we should always have at least one computed index block, but we only write it out if there is more than that.
                                  assert result.columnsIndex.size() > 0;
                                  return result;
                              }
                          }
                      }
                    </code></pre>
                  </details>
                </td>
              </tr>
            </table>
          </details>
        </td>
      </tr>

      <tr>
        <td>
        <details>
          <summary>Case X - cassandra/rev_0f1fb_8b0e1/ColumnIndex.java</summary>
          <ul>
            <li>Construtor do Builder</li>
            <ul>
              <li>Left alterou assinatura, corpo, e adicionou 1 overload</li>
              <li>Right alterou corpo</li>
              <li>Unstructured acusou conflito nos argumentos e no overload</li>
              <li>Safe deu match com vazio, e manteve duas outras versões do método</li>
              <li>MM e KB mantiveram três versões</li>
            </ul>
          </ul>
          <table class="table table-bordered">
            <tr>
              <td>
                <details>
                  <summary>Base</summary>
                  <pre class="prettyprint"><code></code></pre>
                </details>
              </td>
              <td>
                <details>
                  <summary>Left</summary>
                  <pre class="prettyprint"><code>package org.atmosphere.cpr;

    import org.atmosphere.cpr.AtmosphereServlet.Action;
    import org.atmosphere.cpr.AtmosphereServlet.AtmosphereConfig;
    import org.atmosphere.cpr.AtmosphereServlet.AtmosphereHandlerWrapper;

    import java.util.concurrent.ScheduledExecutorService;
    import java.util.concurrent.TimeUnit;

    import static org.atmosphere.cpr.ApplicationConfig.MAX_INACTIVE;
    import static org.atmosphere.cpr.HeaderConfig.X_ATMOSPHERE_ERROR;

    /**
     * Base class which implement the semantics of suspending and resuming of a
     * Comet Request.
     *
     * @author Jeanfrancois Arcand
     */
    public abstract class AsynchronousProcessor implements CometSupport&amp;lt;AtmosphereResourceImpl&amp;gt; {

        private static final Logger logger = LoggerFactory.getLogger(AsynchronousProcessor.class);
    </code></pre>
                </details>
              </td>
              <td>
                <details>
                  <summary>Right</summary>
                  <pre class="prettyprint"><code></code></pre>
                </details>
              </td>
              <td>
                <details>
                  <summary>MergeMethods</summary>
                  <pre class="prettyprint"><code></code></pre>
                </details>
              </td>
              <td>
                <details>
                  <summary>KeepBothMethods</summary>
                  <pre class="prettyprint"><code></code></pre>
                </details>
              </td>
              <td>
                <details>
                  <summary>Safe</summary>
                  <pre class="prettyprint"><code></code></pre>
                </details>
              </td>
              <td>
                <details>
                  <summary>Unstructured</summary>
                  <pre class="prettyprint"><code></code></pre>
                </details>
              </td>
            </tr>
          </table>
        </details>
      </td>
    </tr>
    </table>
    <!--
    <details open>
      <summary>Case X - </summary>
      <p>some observations</p>
      <p>some more observations</p>
      <p>result is<b>ok</b></p>
        <div class="row">
          <div class="col-sm">
            <details>
              <summary>Base</summary>
              <pre class="prettyprint"><code></code></pre>
            </details>
          </div>
          <div class="col-sm">
            <details>
              <summary>Left</summary>
              <pre class="prettyprint"><code>package org.atmosphere.cpr;

    import org.atmosphere.cpr.AtmosphereServlet.Action;
    import org.atmosphere.cpr.AtmosphereServlet.AtmosphereConfig;
    import org.atmosphere.cpr.AtmosphereServlet.AtmosphereHandlerWrapper;

    import java.util.concurrent.ScheduledExecutorService;
    import java.util.concurrent.TimeUnit;

    import static org.atmosphere.cpr.ApplicationConfig.MAX_INACTIVE;
    import static org.atmosphere.cpr.HeaderConfig.X_ATMOSPHERE_ERROR;

    /**
     * Base class which implement the semantics of suspending and resuming of a
     * Comet Request.
     *
     * @author Jeanfrancois Arcand
     */
    public abstract class AsynchronousProcessor implements CometSupport&amp;lt;AtmosphereResourceImpl&amp;gt; {

        private static final Logger logger = LoggerFactory.getLogger(AsynchronousProcessor.class);
    </code></pre>
            </details>
          </div>
          <div class="col-sm">
            <details>
              <summary>Right</summary>
              <pre class="prettyprint"><code></code></pre>
            </details>
        </div>
        <div class="col-sm">
          <details>
            <summary>MergeMethods</summary>
            <pre class="prettyprint"><code></code></pre>
          </details>
        </div>
        <div class="col-sm">
          <details>
            <summary>KeepBothMethods</summary>
            <pre class="prettyprint"><code></code></pre>
          </details>
        </div>
        <div class="col-sm">
          <details>
            <summary>Safe</summary>
            <pre class="prettyprint"><code></code></pre>
          </details>
        </div>
        <div class="col-sm">
          <details>
            <summary>Unstructured</summary>
            <pre class="prettyprint"><code></code></pre>
          </details>
        </div>
      </div>
  </div>
  </table>
  </details> -->

  <div class="d2h-wrapper">
      <div id="d2h-270923" class="d2h-file-wrapper" data-lang="go">
      <div class="d2h-file-header">
      <span class="d2h-file-name-wrapper">
      <span class="d2h-icon-wrapper"><svg aria-hidden="true" class="d2h-icon" height="16" version="1.1" viewBox="0 0 12 16" width="12">
      <path d="M6 5H2v-1h4v1zM2 8h7v-1H2v1z m0 2h7v-1H2v1z m0 2h7v-1H2v1z m10-7.5v9.5c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h7.5l3.5 3.5z m-1 0.5L8 2H1v12h10V5z"></path>
  </svg></span>
      <span class="d2h-file-name">server/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go</span>
      <span class="d2h-tag d2h-changed d2h-changed-tag">CHANGED</span></span>
      </div>
      <div class="d2h-file-diff">
          <div class="d2h-code-wrapper">
              <table class="d2h-diff-table">
                  <tbody class="d2h-diff-tbody">
                  <tr>
      <td class="d2h-code-linenumber d2h-info"></td>
      <td class="d2h-info">
          <div class="d2h-code-line d2h-info">@@ -1035,6 +1035,17 @@ func Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (</div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-cntx">
        <div class="line-num1">1035</div>
  <div class="line-num2">1035</div>
      </td>
      <td class="d2h-cntx">
          <div class="d2h-code-line d2h-cntx">
              <span class="d2h-code-line-prefix"> </span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-cntx">
        <div class="line-num1">1036</div>
  <div class="line-num2">1036</div>
      </td>
      <td class="d2h-cntx">
          <div class="d2h-code-line d2h-cntx">
              <span class="d2h-code-line-prefix"> </span>
              <span class="d2h-code-line-ctn">&#x2F;&#x2F; THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-cntx">
        <div class="line-num1">1037</div>
  <div class="line-num2">1037</div>
      </td>
      <td class="d2h-cntx">
          <div class="d2h-code-line d2h-cntx">
              <span class="d2h-code-line-prefix"> </span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1038</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
              <span class="d2h-code-line-ctn">func Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) {</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1039</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
              <span class="d2h-code-line-ctn">    r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1040</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
              <span class="d2h-code-line-ctn">    n = int(r0)</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1041</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
              <span class="d2h-code-line-ctn">    if e1 != 0 {</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1042</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
              <span class="d2h-code-line-ctn">        err = errnoErr(e1)</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1043</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
              <span class="d2h-code-line-ctn">    }</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1044</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
              <span class="d2h-code-line-ctn">    return</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1045</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
              <span class="d2h-code-line-ctn">}</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1046</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1047</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
              <span class="d2h-code-line-ctn">&#x2F;&#x2F; THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-ins">
        <div class="line-num1"></div>
  <div class="line-num2">1048</div>
      </td>
      <td class="d2h-ins">
          <div class="d2h-code-line d2h-ins">
              <span class="d2h-code-line-prefix">+</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-cntx">
        <div class="line-num1">1038</div>
  <div class="line-num2">1049</div>
      </td>
      <td class="d2h-cntx">
          <div class="d2h-code-line d2h-cntx">
              <span class="d2h-code-line-prefix"> </span>
              <span class="d2h-code-line-ctn">func read(fd int, p []byte) (n int, err error) {</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-cntx">
        <div class="line-num1">1039</div>
  <div class="line-num2">1050</div>
      </td>
      <td class="d2h-cntx">
          <div class="d2h-code-line d2h-cntx">
              <span class="d2h-code-line-prefix"> </span>
              <span class="d2h-code-line-ctn">    var _p0 unsafe.Pointer</span>
          </div>
      </td>
  </tr><tr>
      <td class="d2h-code-linenumber d2h-cntx">
        <div class="line-num1">1040</div>
  <div class="line-num2">1051</div>
      </td>
      <td class="d2h-cntx">
          <div class="d2h-code-line d2h-cntx">
              <span class="d2h-code-line-prefix"> </span>
              <span class="d2h-code-line-ctn">    if len(p) &gt; 0 {</span>
          </div>
      </td>
  </tr>
                  </tbody>
              </table>
          </div>
      </div>
  </div>
  </div>


</body>

</html>
